{"name":"Cross","tagline":"Cross-compiler environment management","body":"cross\r\n=====\r\n\r\ncross is a cross-compiler builder and manager. With cross, generating a \r\ncross compiler for a new architecture is as simple as\r\n```\r\ncross make arm-none-eabi\r\n```\r\n\r\nInstalling `cross`\r\n----------------\r\n\r\nDownload `cross`:\r\n```\r\ngit clone https://github.com/weswigham/cross.git ~/.cross\r\n```\r\n\r\nThen add the cross bin and shims to the end of your bash/zsh/other profile:\r\n```\r\necho 'export PATH=\"$HOME/.cross/shims:$HOME/.cross/bin:$HOME/.cross/cmd:$PATH\"' >> ~/.bash_profile\r\n```\r\n\r\nAnd then restart your shell.\r\n\r\nDependencies\r\n------------\r\n`cross` itself depends on `lua` and a shell environment. It also makes use of `git`, `svn`, and potentially `hg` for version control.\r\n\r\nGCC depends on a large number of things, including `autoconf`, `automake`, `autopoint`, `gettext`, and `texinfo` to build, and possibly more. You can find out either by interpreting GCC's errors when you attempt to compile, or by looking them up at http://gcc.gnu.org/install/prerequisites.html.\r\n\r\nUsing `cross`\r\n-----------\r\n\r\nInstalling a new cross compiler\r\n```\r\ncross make arm-none-eabi\r\n```\r\nWhich will download, compile, and install `arm-none-eabi` platform tools, so you can\r\n```\r\narm-none-eabi-gcc hello.c -o hello\r\n```\r\n\r\n\r\n\r\n`cross` subcommands\r\n-------------------\r\n\r\n`cross` comes bundled with a few useful commands.\r\n\r\n_make_\r\n```\r\ncross make TARGET [BUILD_PARAMS ...]\r\n```\r\n'TARGET' is your standard target triple, such as 'x86_64-pc-mingw32'.\r\n\r\n'BUILD_PARAMS' are parameters in the form KEY=VALUE which override any other configuration options. More on those later.\r\n\r\n_version_\r\n```\r\ncross version\r\n```\r\nOutputs the `cross` version number.\r\n\r\n_help_\r\n```\r\ncross help [subcommand]\r\n```\r\nOutputs either the list of subcommands or the help text for a specific subcommand.\r\n\r\nTarget Configurations\r\n---------------------\r\nCross comes bundled with what could be considered 'sane defaults' for _embedded systems_-type target architectures. The head version of \r\nGCC is built first without headers, then newlib is built with that GCC, then GCC is rebuilt again \r\nwith newlib as the included C library.\r\n\r\nFor quite a few targets these defaults work pretty okay, but if they don't, `cross` is highly configurable. \r\n`cross` looks in its _cmd/targets_ directory for files named after the target given. If it exists, the file is loaded\r\nas a lua table and searched for override parameters. Parameters it looks for include:\r\n\r\n###`SKIP_BISON` or `SKIP_FLEX`\r\nThese, if present, make the build system skip building both flex and bison (prerequisites for building GCC)\r\n\r\n###`t_VERSION`\r\nWhere 't' is any of FLEX, BISON, BINUTILS, GCC, GCC_2, or LIBC \r\nThis, by default, indicates a specific version of that dependency is necessary. `cross` will try to checkout the given version from the repo (with hg/git/svn tags).\r\n\r\n###`t_OVERRIDE` \r\nWhere 't' is any of FLEX, BISON, BINUTILS, GCC, GCC_2, or LIBC \r\nThis lets you specify a table to completely override that stage of the build.\r\nThe table has the fields 'target' and 'output' set to its output dir and target-triple,\r\nThen, if the table specifies a 'method' (and, implicitly, a 'url') field, then\r\nthe `cross` internal source control function is used to download that version.\r\nIf `method` is not specified, `cross` expects the table to be callable, and return the directory that dependency's source is in when called. \r\n`cross` also expects the override table to have a 'builder' string. This string has the override table applied to it as a handlebars-esque context\r\nand then is run from the shell from within the directory the source is in. This is usually something as simple as\r\n```\r\n./configure; make; make install;\r\n```\r\n\r\nAny combination of these can be present in the table, and they can be overridden again with parameters to the `make` subcommand.\r\n\r\nAs an example, you can force `cross` to build GCC 4.8.0 on `arm-none-eabi` by making the file `~/.cross/cmd/targets/arm-none-eabi`:\r\n```\r\nGCC_2_VERSION = \"gcc-4_8_0-release\", --for the final compilation\r\nGCC_VERSION = \"gcc-4_8_0-release\", --since it's probably a good idea to build the same version when we bootstrap\r\n```\r\n\r\n\r\nHow cross works\r\n---------------\r\ncross is based off of `rbenv`. As such, there are a number of similarities. Namely, shims. Unlike rbenv, you should never need \r\nto `rehash` yourself, just leave it to cross. \r\n\r\nWhy does `cross` have shims? To enable a feature called a 'target override'. \r\nIf you want to `make` something for a new target, usually you'd need to make a new makefile referencing the new target's build executables.\r\ncross alleviates this need. Instead, place a .cross_target file in the same directory as the makefile and make its contents your desired target.\r\ni.e.:\r\n```\r\necho \"arm-none-eabi\" >> .cross_target\r\n```\r\ncross's shims will look for this file when you run gcc, g++, or any executable compiled by cross and override it with the target-specific version when this file is present.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}